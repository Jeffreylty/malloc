/*
 * mm-naive.c - The fastest, least memory-efficient malloc package.
 * 
 * In this naive approach, a block is allocated by simply incrementing
 * the brk pointer.  A block is pure payload. There are no headers or
 * footers.  Blocks are never coalesced or reused. Realloc is
 * implemented directly using mm_malloc and mm_free.
 *
 * NOTE TO STUDENTS: Replace this header comment with your own header
 * comment that gives a high level description of your solution.
 */
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <unistd.h>
#include <string.h>

#include "mm.h"
#include "memlib.h"

/*********************************************************
 * NOTE TO STUDENTS: Before you do anything else, please
 * provide your team information in the following struct.
 ********************************************************/
team_t team = {
    /* Team name */
    "team",
    /* First member's full name */
    "Gao Fan",
    /* First member's email address */
    "gfan@u.rochester.edu",
    /* Second member's full name (leave blank if none) */
    "Siyang Zhang",
    /* Second member's email address (leave blank if none) */
    "szhang58@u.rochester.edu"
};

/* single word (4) or double word (8) alignment */
#define ALIGNMENT 8

/* rounds up to the nearest multiple of ALIGNMENT */
#define ALIGN(size) (((size) + (ALIGNMENT-1)) & ~0x7)

/* Basic constants and macros */
#define WSIZE 4             /* Word and header/footer size (bytes) */
#define DSIZE 8             /* Double word size (bytes) */ 
#define CHUNKSIZE (1<<12)   /* Extend heap by this amount (bytes) */

#define MAX(x, y) ((x) > (y) ? (x) : (y))
#define MIN(x, y) ((x) < (y) ? (x) : (y))

/* Pack a size and allocated bit into a word */
#define PACK(size, alloc) ((size) | (alloc))

/* Read and write a word at address p */
#define GET(p) (*(unsigned int *)(p)) 
#define PUT(p, val) (*(unsigned int *)(p) = (val) | GET_TAG(p))
#define PUTNOTAG(p, val) (*(unsigned int *)(p) = (val))

/* Read the size and allocated fields from address p */
#define GET_SIZE(p) (GET(p) & ~0x7) 
#define GET_ALLOC(p) (GET(p) & 0x1)

/* Read and change the tag */
#define GET_TAG(p)   (GET(p) & 0x2)
#define SET_TAG(p)   (GET(p) |= 0x2)
#define REMOVE_TAG(p) (GET(p) &= ~0x2)

/* Given block ptr bp, compute address of its header and footer */
#define HDRP(bp) ((char *)(bp) - WSIZE) 
#define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)

/* Given block ptr bp, compute address of next and previous blocks */
#define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE))) 
#define PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))

/* Address of free block's next and prev entries*/
#define NEXT_PTR(bp)  ((char *)(bp))
#define PREV_PTR(bp)  ((char *)(bp) + WSIZE)

/* Address of Address of free block's next and prev on free list */
#define NEXT(bp) (*(char **)(bp))
#define PREV(bp) (*(char **)(PREV_PTR(bp)))

/* Change free block's next and prev pointer */
#define SET_PTR(p, ptr) (*(unsigned int *)(p) = (unsigned int)(ptr))
#define SET_NEXT_PTR(bp, p) (*(unsigned int *)(NEXT_PTR(bp)) = (unsigned int)p)
#define SET_PREV_PTR(bp, p) (*(unsigned int *)(PREV_PTR(bp)) = (unsigned int)p)

int check = 0;
static char *heap_listp;    /* Heap pointer */
static void **free_listp;   /* Free list pointer */
size_t free_list_size = 20; /* Free list size */

/* Helper functions*/
static void *extend_heap(size_t size);
static void *coalesce(void *ptr);
static void *place(void *bp, size_t size);
static void *find_fit(size_t asize);
static int  search(size_t asize);
static void insert(void *bp, size_t size);
static void delete(void *bp);
static void mm_check(int check);
static void mm_checkblock(void *bp);

/* 
 * extend_heap - Extend heap based on input size
 */
static void *extend_heap(size_t size) {
    char *bp; 
    size_t asize;

    /* Allocate an even number of words to maintain alignment */ 
    asize = ALIGN(size);

    /* If invalid size */
    if ((bp = mem_sbrk(asize)) == (void*)-1) 
        return NULL;

    /* Initialize free block header/footer and the epilogue header */ 
    PUTNOTAG(HDRP(bp), PACK(asize, 0));           /* Free block header */ 
    PUTNOTAG(FTRP(bp), PACK(asize, 0));           /* Free block footer */ 
    PUTNOTAG(HDRP(NEXT_BLKP(bp)), PACK(0, 1));    /* New epilogue header */
    insert(bp, asize);

    /* Coalesce if the previous block was free */ 
    return coalesce(bp);
}

/* 
 * coalesce - Merge free blocks on given ptr
 */
static void *coalesce(void *bp) {
    size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp))); 
    size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp))); 
    size_t size = GET_SIZE(HDRP(bp));

    /* Regard tagged block as allocated block */
    if (GET_TAG(HDRP(PREV_BLKP(bp))))
        prev_alloc = 1;

    if (prev_alloc && next_alloc) {         /* No free blocks */
        return bp; 
    }
    else if (prev_alloc && !next_alloc) {   /* Next block is free */
        delete(bp);
        delete(NEXT_BLKP(bp));
        size += GET_SIZE(HDRP(NEXT_BLKP(bp))); 
        PUT(HDRP(bp), PACK(size, 0)); 
        PUT(FTRP(bp), PACK(size, 0)); 
    }
    else if (!prev_alloc && next_alloc) {   /* Prev block is free */
        delete(bp);
        delete(PREV_BLKP(bp));
        size += GET_SIZE(HDRP(PREV_BLKP(bp))); 
        PUT(FTRP(bp), PACK(size, 0)); 
        PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0)); 
        bp = PREV_BLKP(bp); 
    }
    else {                                  /* Both blocks are free */
        delete(bp);
        delete(PREV_BLKP(bp));
        delete(NEXT_BLKP(bp));
        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(HDRP(NEXT_BLKP(bp))); 
        PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0)); 
        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, 0)); 
        bp = PREV_BLKP(bp); 
    } 
    insert(bp, size);                       /* Insert free block back to free list */
    return bp;
}

/*  
 * place - Add block with given size to ptr
 */
static void *place(void *bp, size_t size){
    size_t asize = GET_SIZE(HDRP(bp));
    size_t remainsize = asize - size;

    delete(bp);

    if (remainsize > DSIZE*2){     /* If remain size can be regarded as free blcok */
        PUT(HDRP(bp), PACK(size, 1));
        PUT(FTRP(bp), PACK(size, 1));
        PUTNOTAG(HDRP(NEXT_BLKP(bp)), PACK(remainsize, 0));
        PUTNOTAG(FTRP(NEXT_BLKP(bp)), PACK(remainsize, 0));
        insert(NEXT_BLKP(bp), remainsize);
    }else{                          /* If remain size is too small */
        PUT(HDRP(bp), PACK(asize, 1));
        PUT(FTRP(bp), PACK(asize, 1));
    }

    return bp;
}

/*  
 * find_fit - Find the free block based on given size, return the ptr
 *     Always return the best fit block since free list is in ascending order
 */
static void *find_fit(size_t asize){
    int index = search(asize);
    void *bp;
    int i;

    /* For all blocks with size equal to or greater than asize */
    for (i = index; i < free_list_size; i++){ 
        bp = free_listp[i];

        /* Check if valid */
        while ((bp != NULL) && ((asize > GET_SIZE(HDRP(bp))) || (GET_TAG(HDRP(bp)))))
            bp = NEXT(bp);
        /* Return if found */
        if (bp != NULL)
            return bp;
    }

    return NULL;
}

/* 
 * search - Return the corresponding index of given size on free list
 */
static int search(size_t asize){
    int index = 0;
    size_t size = asize;

    while ((index < free_list_size - 1) && (size > 1)){
        size = size>>1;     /* Divide size by 2 */
        index++;            /* Increase index */
    }

    return index;
}

/*
 * insert - Insert the given block to the free list
 */
static void insert(void *bp, size_t size){
    int index = search(size);
    void *next = bp;
    void *prev = NULL;

    /* Find the fit position in ascending free list */
    next = free_listp[index];
    while((next != NULL) && (size > GET_SIZE(HDRP(next)))){
        prev = next;
        next = NEXT(next);
    }

    if (prev != NULL){
        if (next != NULL){          /* Has prev and next */
            SET_PREV_PTR(bp, prev);
            SET_NEXT_PTR(prev, bp);
            SET_NEXT_PTR(bp, next);
            SET_PREV_PTR(next, bp);
        }else{                      /* Has prev */
            SET_PREV_PTR(bp, prev);
            SET_NEXT_PTR(prev, bp);
            SET_NEXT_PTR(bp, NULL);
        }
    }else{
        if (next != NULL){          /* Has next */
            SET_PREV_PTR(bp, NULL);
            SET_NEXT_PTR(bp, next);
            SET_PREV_PTR(next, bp);
        }else{                      /* Has nothing */
            SET_PREV_PTR(bp, NULL);
            SET_NEXT_PTR(bp, NULL);
        }
        free_listp[index] = bp;
    }
}

/*
 * delete - Remove the given block from the free list
 */
static void delete(void *bp){
    int index = search(GET_SIZE(HDRP(bp)));

    if (PREV(bp) != NULL){
        if (NEXT(bp) != NULL){              /* Has prev and next */
            SET_NEXT_PTR(PREV(bp), NEXT(bp));
            SET_PREV_PTR(NEXT(bp), PREV(bp));
        }else{                              /* Has prev */
            SET_NEXT_PTR(PREV(bp), NULL);
        }
    }else{
        if (NEXT(bp) != NULL){              /* Has next */
            SET_PREV_PTR(NEXT(bp), NULL);
            free_listp[index] = NEXT(bp);
        }
        else{                               /* Has nothing */
            free_listp[index] = NULL;
        }
    }
}

/* 
 * mm_init - initialize the malloc package.
 */
int mm_init(void)
{
    /* Initialize segregated free list */
    free_listp = mem_sbrk(free_list_size*WSIZE);

    /* Set all entries to NULL */
    int index;
    for (index = 0; index < free_list_size; index++){
        free_listp[index] = NULL;
    }

    /* Initialize heap */
    if ((long)(heap_listp = mem_sbrk(4 * WSIZE)) == -1) 
        return -1; 

    /* Add necessary header and footer */
    PUTNOTAG(heap_listp, 0);                             /* Alignment padding */ 
    PUTNOTAG(heap_listp + (1*WSIZE), PACK(DSIZE, 1));    /* Prologue header */ 
    PUTNOTAG(heap_listp + (2*WSIZE), PACK(DSIZE, 1));    /* Prologue footer */ 
    PUTNOTAG(heap_listp + (3*WSIZE), PACK(0, 1));        /* Epilogue header */ 
    heap_listp += (2*WSIZE);

    /* Extend the empty heap with a free block of CHUNKSIZE bytes */ 
    if (extend_heap(CHUNKSIZE/WSIZE) == NULL) 
        return -1;

    return 0;
}

/* 
 * mm_malloc - Allocate a block by incrementing the brk pointer.
 *     Always allocate a block whose size is a multiple of the alignment.
 */
void *mm_malloc(size_t size)
{
    size_t asize;       /* Adjusted block size */
    size_t extendsize;  /* Amount to extend heap if no fit */
    void *bp = NULL;    /* Pointer */

    /* Ignore spurious requests */
    if (size == 0)
        return NULL;

    /* Adjust block size to include overhead and alignment reqs. */
    if (size <= DSIZE) {
        asize = 2 * DSIZE;
    } else {
        asize = ALIGN(size+DSIZE);
    }

    /* Search the free list for a fit */ 
    if ((bp = find_fit(asize)) == NULL) {

        /* If no fit found, extend heap */ 
        extendsize = MAX(asize,CHUNKSIZE); 
        if ((bp = extend_heap(extendsize)) == NULL) 
            return NULL; 
    }
    
    place(bp, asize); 
    mm_check(check);
    return bp;
}

/*
 * mm_free - Freeing a block does nothing.
 */
void mm_free(void *bp)
{
    size_t size = GET_SIZE(HDRP(bp));

    /* Change header footer and tag */
    REMOVE_TAG(HDRP(NEXT_BLKP(bp)));
    PUT(HDRP(bp), PACK(size, 0)); 
    PUT(FTRP(bp), PACK(size, 0)); 

    /* Insert to free list and coalesce */
    insert(bp, size);
    coalesce(bp);
    
    mm_check(check);
}

/*
 * mm_realloc - Implemented simply in terms of mm_malloc and mm_free
 *     Use tag at 0x2 to optimize performance
 */
void *mm_realloc(void *bp, size_t size)
{
    size_t asize = size;    /* Size of new block */
    int extendsize;         /* Size to extend heap */
    int buffersize;         /* Size of block buffer */
    int remainsize;         /* Size of reminder */
    void *newp = bp;        /* Ptr to the result block */

    /* Ignore spurious requests */
    if (size == 0)
        return NULL;

    /* Adjust block size to include overhead and alignment reqs. */
    if (asize <= DSIZE) {
        asize = 2 * DSIZE;
    } else {
        asize = ALIGN(size+DSIZE);
    }

    /* Add overhead requirements to block size */
    asize += (1<<7);

    /* Calculate block buffer */
    buffersize = GET_SIZE(HDRP(bp)) - asize;

    /* Extend if overhead falls below the minimum */
    if (buffersize < 0){

        /* If next block is free or epilogue */
        if (!GET_ALLOC(HDRP(NEXT_BLKP(bp))) || !GET_SIZE(HDRP(NEXT_BLKP(bp)))){

            /* Combine the size of those two blocks and compare with asize*/
            remainsize = GET_SIZE(HDRP(bp)) + GET_SIZE(HDRP(NEXT_BLKP(bp))) - asize;

            /* Extend if necessary */
            if (remainsize < 0){
                extendsize = MAX(-remainsize, CHUNKSIZE);
                if (extend_heap(extendsize) == NULL)
                    return NULL;
                remainsize += extendsize;
            }

            delete(NEXT_BLKP(bp));

            /* Change header and footer */
            PUTNOTAG(HDRP(bp), PACK(asize + remainsize, 1));
            PUTNOTAG(FTRP(bp), PACK(asize + remainsize, 1));
        }

        /* If next block is not free or epilogue */
        else{
            newp = mm_malloc(asize - DSIZE);    /* malloc for new size */
            memcpy(newp, bp, MIN(size, asize)); /* Copy the content to the new block */
            mm_free(bp);                        /* Free the old block */
        }

        /* Update block buffer */
        buffersize = GET_SIZE(HDRP(newp)) - asize;
    }

    /* Tag the next block if block overhead drops below twice the overhead */
    if (buffersize < 2*(1<<7))
        SET_TAG(HDRP(NEXT_BLKP(newp)));

    mm_check(check);
    return newp;
}

/* 
 * mm_check - Check the consistency of heap
 */
void mm_check(int check) {
    if (check){
        void *bp;

        /* Check prelogue */
        if (GET_SIZE(HDRP(heap_listp)) != DSIZE || !GET_ALLOC(HDRP(heap_listp)))
            printf("Bad prologue header\n");
        mm_checkblock(heap_listp);

        /* Check regular blocks */
        for (bp = heap_listp; GET_SIZE(HDRP(bp)) > 0; bp = (void *)NEXT_BLKP(bp))
            mm_checkblock(bp);

        /* Check epilogue */
        if (GET_SIZE(HDRP(bp)) != 0 || !GET_ALLOC(HDRP(bp)))
            printf("Bad epilogue header\n");
    }
}

/* 
 * mm_checkblock - Check the consistency of a regular block
 */
void mm_checkblock(void* bp){
    /* Check consistency between header and footer */
    if ((GET_SIZE(HDRP(bp)) != GET_SIZE(FTRP(bp))) || GET_ALLOC(HDRP(bp)) != GET_ALLOC(FTRP(bp)))
        printf("Error: header does not match footer\n");

}

